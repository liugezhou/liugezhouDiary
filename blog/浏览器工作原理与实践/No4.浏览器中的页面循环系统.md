### Noo4.浏览器中的页面循环系统

###### 前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。  

###### 本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。
<!--more-->
#### 15｜消息队列和事件循环：页面是怎么“活”起来的？
---
> 本节主要专门介绍页面的事件循环系统，希望通过几句总结能对页面的事件循环系统有一个整体上的理解。    
##### 使用单线程处理安排好的任务
> 单线程处理的流程就是把所有任务代码按照顺序写进主线程里，等线程运行时，这些任务按照顺序在线程中执行，等所有任务执行完成，线程自动退出。        
##### 在线程运行过程中处理任务
> 当然并非所有任务都可以使用单线程处理，有时我们需要在线程运行的过程中处理任务。    
> 那么要想在线程运行过程中，能接受并执行新的任务，就需要采用事件循环机制。
> 相较与单线程处理任务，此线程做了两点改进：  
> + 引入了循环机制。(比如一个实现方式是添加for循环。线程一直循环执行)。 
> + 引入了事件。
##### 处理其他线程发送过来的任务
> 如何设计好一个线程模型，能让其能够接受其他线程发送的消息呢？  
> 一个通用的模式是消息队列：「消息队列是一种数据结构、可以存放要执行的任务。它符合队列“先进先出”的特点。」      
> 有了队列之后继续改进步骤如下：    
> + 添加一个消息队列。  
> + IO线程中产生的新任务添加进消息队列尾部。    
> + 渲染主进程会循环地从消息队列头部中读取任务，执行任务。  
##### 处理其他进程发送过来的任务
> 渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前面的“处理其他线程发送的任务”一样。    
##### 消息队列中的任务类型
> 消息队列中的任务都有哪些呢？  
> 输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。    
##### 页面使用单线程的缺点
> + 第一个问题是如何处理高优先级的任务。    
> 由于优先级的问题使得微任务应用而生，微任务是如何权衡效率和实时性的呢? 
> 通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题.等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题   
> + 第二个是如何解决单个任务执行时长过久的问题. 
>  针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。  
##### 总结
> 如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。    
> 要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。  
> 如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。    
> 如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。    
> 消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。
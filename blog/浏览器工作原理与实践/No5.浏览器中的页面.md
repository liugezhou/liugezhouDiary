### No5.浏览器中的页面

###### 前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。  

###### 本篇是这个专栏的第四章：《No5.浏览器中的页面》。本章分为八节。
<!--more-->

#### 21 ｜ Chrome开发者工具：利用网络面板做性能分析
---
> 本节首先对开发者工具的各个模块进行了一个简单介绍，然后重点讲解的是NetWork面板。   
> 网络面板包括：控制器、过滤器、抓图信息、时间线、详细列表和下载信息概要六个区域构成。    

##### 1.控制器 
> + “开始/暂停”抓包。   
> + 全局搜索。    
> + Disable cache:禁止从Cache中加载资源。
> + Online按钮：模拟2G/3G 网络，模拟弱网环境。  
##### 2.过滤器
> 过滤功能。 

##### 3.抓图信息
> 抓图信息区域，可以用来分析用户等待页面加载时间内所看到的内容，分析用户实际的体验情况。  

##### 4.时间线
> 时间线，主要用来展示 HTTP、HTTPS、WebSocket 加载的状态和时间的一个关系，用于直观感受页面的加载过程。

##### 5.详细列表    
> 详细记录了每个资源从发起请求到完成请求这中间所有过程的状态，以及最终请求完成的数据信息.   
> Queuing：当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。  
> Stalled： 在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的 Stalled 上。   
> Proxy Negotiation:若使用代理服务器，会增加一个此阶段。    
> Waiting (TTFB):通常也称为“第一字节时间”。 TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。    
> Content Download :这意味着从第一字节时间到接收到全部响应数据所用的时间。  

##### 6.下载信息概要    
> 重点关注 DOMContentLoaded和Load两个事件。 
> + DOMContentLoaded:这个事件发生后，说明页面已经构建好DOM了，即DOM需要的HTML、JavaScript、CSS等文件已下载完成了。  
> + Load：说明浏览器已经加载了所有的资源(图像、样式等)。    

#### 22 | DOM树：JavaScript是如何影响DOM树构建的？
---
##### 什么是DOM
> DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。   

##### DOM树如何生成
> 在渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。 
> HTML解析器过程是：网络进程加载了多少数据，HTML解析器便解析多少数据。  

##### JavaScript是如何影响DOM生成的
> + 在两段 div 中间插入了一段 JavaScript 脚本：当HTML解析器解析到script标签的时候会暂停DOM解析，去执行这段JS脚本。 
> + 在页面中引入 JavaScript文件：整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先`下载这段 JavaScript 代码`。这里需要重点关注`下载环境`，因为 JavaScript 文件的下载过程会阻塞 DOM 解析(Chrome浏览器做的一个主要优化是预解析操作)。
> 另外也有一些相关的策略：比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为`异步加载`，通过 `async `或`defer` 来标记代码.  
> 1. async:使用 async 标志的脚本文件一旦加载完成，会立即执行.    
> 2. defer:使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行.

> 通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的。

#### 23 ｜ 渲染流水线：CSS如何影响首次加载时的白屏问题
---
> CSS资源是页面中非常重要的一环，本节首先站在渲染流水线的视角来介绍CSS是如何工作的、然后通过CSS工作流程来分分析性能瓶颈、最后讨论如何减少首次加载时的白屏问题。 
##### 渲染流水线视角下的CSS
> 首先是发起页面请求，网络进程接收到返回的HTML数据，将其发送给渲染进程，渲染进程解析HTML数据并构建DOM。 
> 需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。   

> 前面提到一嘴：Chrome浏览器做的一个主要优化是预解析操作。  
> 因此，Chrome开启这个预解析进程后，在遇到JavaScript或CSS文件后，会提前下载这些文件。   
> 这里也有一个空闲时间需要注意一下，就是在 DOM 构建结束之后、css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。 

> CSSOM的两个作用： 
> + 提供给 JavaScript 操作样式表的能力. 
> + 为布局树的合成提供基础的样式信息。

##### 影响页面展示的因素以及优化策略
> 从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段:    
> 1. 等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。   
> 2. 提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染.  
> 3. 等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。   

> 这里重点关注第二个阶段：  
> 该阶段的主要任务包括了：解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。   
> 对应策略：
> + 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。    
> + 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。 
> + 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。    
> + 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。 

#### 24 | 分层和合成机制：为什么CSS动画比JavaScript高效
---
> 在第五节的时候，我们知道DOM构建成功后还要经历布局、分层、绘制、合成、显示等阶段后才能显示出漂亮的页面。 
> 这一节主要讲解的是渲染引擎的分层和合成机制，作者说分层和合成机制代表了浏览器最为先进的合成技术，请注意是`最为先进的`. 
##### 显示器是怎么显示图像的
> 每个显示器的固定刷新频率通常是60HZ，即每秒更新60张图片，更新的图片都来自显卡中一个叫前缓冲区的地方，，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。  
> 显卡的作用：显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。  

##### 帧 VS 帧率
> 渲染流水线生成的每一张图片称为一帧，渲染流水线每秒更新了多少帧称为帧率。  

##### 如何生成一帧图像
> 生成一帧图像有三种方式：重排、重绘、合成。 这三种方式的渲染路径不同，通常渲染路径越长，生成图像花费的时间越久。  
> 这里聚焦点在合成上 ，为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制，Chrome的合成技术用三个词来概括：分层、分块、合成。

##### 分层和合成
> 你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，将素材分解为多个图层的操作就称为分层。最后将这些图层合并到一起的操作就称为合成。  
> 在Chrome渲染流水线中，分层体现在生成布局树之后，渲染引擎根据布局树的特点将其转化为层树，层树是渲染流水线后续流程的基础结构。  
> 需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。

##### 分块
> 如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。    
> 在首次合成图块的时候使用一个低分辨率的图片。

##### 如何利用分层技术优化代码
> 在写 Web 应用的时候，你可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下.  
> 这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：
```
    .box {
        will-change: transform, opacity;
    }
```
> 这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因.   

#### 25 ｜ 页面性能：如何系统地优化页面？
---


# Oct-01,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*Study hard and you'll improve everyday.*</u>
#### <u>*If you think you can do better,then go ahead.*</u>
#### <u>*How should I know?*</u>
> 

## **Plan**
> 这里记录我的一天，需要去留意的事。

## **Summary**
> 今日放假，嘀嗒到了aliya的家。
> 稍稍了解了一下每个仓库的Wiki。

> VSCode查看代码目录结构：Command + Shfit + O


</p>
</details>

---

# Oct-02,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*夜不能寐，辗转反侧。我还是需要去做点什么，充实一下心灵。*</u>
> 

## **Plan**
> 这里记录我的一天，需要去留意的事。

## **Summary**
> 此刻早晨六点十六，等待着跟aliya一家人回家看看。

> 晚上三点半的时候醒来便不能睡去。

> 焦灼着与身边人的关系。我想象着，来到这个世界上，不能作为一个个人而独立存在，必须要与身边的人形成一个团体，抱团取暖，但是我却在与身边的人相处当中发起了难。

> 究竟应该以什么样的姿态相处？ 大抵不过 天生我材必有用，千金散尽还复来吧。

> 追求心灵的满足与宁静是人生的课题罢。

</p>
</details>

---

# Oct-03,2019

<details><summary><b>DETAILS</b></summary>
<p>

> 白天在家睡了一下午。

> 晚上跟兄弟们聚了个餐，喝了一壶，然后突然想到了老贾，晚上又打车去找了他。

> 发生了一些趣事，晚上回来打车还吐了人家车，人家找我赔钱，我竟然恐吓找人来揍人家，啊哈哈。
</p>
</details>

---

# Oct-04,2019

<details><summary><b>DETAILS</b></summary>
<p>

> 在家一天。

> 哪也没去。
</p>
</details>

---

# Oct-06,2019

<details><summary><b>DETAILS</b></summary>
<p>

> 晚上失眠到两点多才睡觉，稀里糊涂想了一些东西，睡醒之后也忘却了。

> 早晨五点起床收拾了一下，去邯郸火车站接了下强强的亲家，然后在强强家就这么呆了一天。

> 明天我的这个小侄子都要结婚了，是时候把我自己的事情提上日程了。

> 最让我感觉到有些担心的还是自己在工作上的不进步，有些微微的惊恐。

</p>
</details>

---

# Oct-07,2019

<details><summary><b>DETAILS</b></summary>
<p>

> 最终还是在下午打车，赶回了北京。

> 23:05:33
</p>
</details>

---

# Oct-08,2019

<details><summary><b>DETAILS</b></summary>
<p>

> ## **Daily Sentence**
#### <u>*节后第一班，没有去上班。*</u>
> 

## **Plan**
> 这里记录我的一天，需要去留意的事。

> 合并aliya的代码提交。--Done
> 梳理接下来的工作、生活，目标清晰，逐步推进。

## **Summary**
#### 杂感一下
> 今天请假在家。有一种莫名的不知所措。
>
> 原先是要计划一下，开始上班后的生活、工作的，然后一个慵懒的午后，大脑陷入混沌。
>
> 各种碎片消息令人应接不暇。我的心态又开始波动，谈到爱国主义的时候，我总是对自己产生怀疑。为什么我就没有那种爱国情怀，为什么我不能融入到那种爱国情怀中去？为什么我在这篇广袤无际的土地上，显得格外的异类。这种感受真的是很痛苦、而且特别是在别人沉浸在爱过情怀中，我突然的发表自我观点，更会把我打入一个愤青、反动的阵营。我想面对此种事件，我以后最好的做法是保持沉默。
>
> 十一回家，种种说不口的话，让我明白我还不是一个会担当一些事情的男人，我活在自己的生活中太久，与他人的一句寒暄、一句问候都出了问题。
>
> 当务之急，要在这份迷失中去纠正自己的感受、增加自我信心，感受生命馈赠。
#### 小结
> 1. 拍婚纱照、领证、婚宴三部曲。
>
> 2. 完成现存工作项目的后端支付接口。
>
> 3. 前端体系重学、新学。

</p>
</details>

---
# Oct-09,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*Nothing is more dangerous than discontinued labor.*</u>
> 没有什么比半途而废更危险的了。

## **Plan**
>这里记录我的一天，需要去留意的事。

> 首先是xmind图的一个更新。
> 其次是项目的重新clone、照着例子先写它十个接口。

## **Summary**
| 标签  | 记录  | 评价  |
| :---: | :---: | :---: |
|   xmind    |   未更新    | ⭐  |
|   项目配置    |   Done    | ⭐⭐⭐  |
> xmind图暂时还来不及更新，支付宝的接口还需要捋一下。

> 上午开了一上午的会，明确了自己接下来要做的事情。
> 下午开始苦逼的项目配置，完全看不懂这个项目、代码、配置等等等等。一个接口都犯难。
> 项目配置步骤：
> 1.git clone -b dev 仓库地址
> 2.重新下载maven、配置本地maven环境变量。
> 3.反复试错，直至可以package。

</p>
</details>

---

# Oct-10,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*The choose time is save time.*</u>
> 

## **Title**
> 白天的主要动弹为：项目接口的代码编写，写的有点乱、有些杂，主要就是写一些接口声明以及一些实体类的定义。
> Oct 10,Night，学了一些Java的基础知识.

#### Java
> 一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。
> + 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。
> + 类：类是一个模板，它描述一类对象的行为和状态。
> + 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。
> + 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。

#### Java基础语法
> + 大小写敏感：Java是大小写敏感的。
> + 类名：对于所有的类来说，类名的首字母应该大写。
> + 方法名：所有的方法名都应该以小写字母开头。
> + 源文件名：源文件名必须和类名相同。
> + 主方法入口：所有的 Java 程序由 public static void main(String []args) 方法开始执行。

### Java修饰符
> + 访问控制修饰符 : default, public , protected, private
> + 非访问控制修饰符 : final, abstract, static, synchronized

### Java变量
> + 局部变量
> + 类变量（静态变量）
> + 成员变量（非静态变量）

### Java枚举
> Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug。
> 例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。
实例
```
class FreshJuice {
   enum FreshJuiceSize{ SMALL, MEDIUM , LARGE }
   FreshJuiceSize size;
}
 
public class FreshJuiceTest {
   public static void main(String []args){
      FreshJuice juice = new FreshJuice();
      juice.size = FreshJuice.FreshJuiceSize.MEDIUM  ;
   }
}
```
> 注意：枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义。

### Java继承
> 在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。
> 利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。

### Java接口
> 在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。
> 接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。

### Java作为一种面向对象语言，支持以下基本概念：
> + 多态    
> + 继承
> + 封装
> + 抽象
> + 类
> + 对象
> + 实例
> + 方法
> + 重载
### 对象和类
> 对象：对象是类的一个实例
> 类：类是一个模板，它描述一类对象的行为和状态。
### 一个类可以包含以下类型的变量
> + 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量
> + 成员变量：成员变量是定义在类中，方法体之外的变量。
> + 类变量：类变量也声明在类中，方法体之外，但必须声明为`static`类型。
### 构造方法
> 每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。
> 在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。
### 创建对象
> 对象是根据类创建的。  
> 在Java中，使用关键字new来创建一个对象，创建对象需要经过以下步骤：  
> + 声明： 声明一个对象，包括对象名称和对象类型。  
> + 实例化： 使用关键字new来创建一个对象。  
> + 初始化：使用new创建对象时，会调用构造方法初始化对象。
下面是一个创建对象的例子：
```
public class Puppy{
   public Puppy(String name){
      //这个构造器仅有一个参数：name
      System.out.println("小狗的名字是 : " + name ); 
   }
   public static void main(String[] args){
      // 下面的语句将创建一个Puppy对象
      Puppy myPuppy = new Puppy( "tommy" );
   }
}
```
### 源文件声明规则
>源文件的声明规则。当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。

> + 一个源文件中只能有一个public类  
> + 一个源文件可以有多个非public类  
> + 源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。  
> + 如果一个类定义在某个包中，那么package语句应该在源文件的首行。
如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。  
> + import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。  
> + 类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在访问控制章节介绍。
### Java包
> 包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。
### Import语句
> 在Java中，如果给出一个完整的限定名，包括包名、类名，那么Java编译器就可以很容易地定位到源代码或者类。Import语句就是用来提供一个合理的路径，使得编译器可以找到某个类。
### Java的两大数据类型
> ##### 内置数据类型（基本数据类型）
> Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。  
> + byte  
> + short  
> + int  
> + long  
> + float  
> + double  
> + boolean  
> + char  
> ##### 引用数据类型
> 对象数组都是引用数据类型。
### Java常量
>常量在程序运行时是不能被修改的。  
> 在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：  
> final double PI = 3.1415927;
### 自动类型转换
> 整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。  
> 转换从低级到高级。  
> 低  ------------------------------------>  高  
> byte,short,char—> int —> long—> float —> double   
>
> 数据类型转换必须满足如下规则：
> 1. 不能对boolean类型进行类型转换。
> 2. 不能把对象类型转换成不相关类的对象。
> 3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。
> 4. 转换过程中可能导致溢出或损失精度，  
> 例如：  
> int i =128;     
> byte b = (byte)i;  
> 因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。
> 5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：  
> (int)23.7 == 23;        
> (int)-45.89f == -45
</p>
</details>

---

# Oct-11,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*No other misfortune can be compared with the loss of time.*</u>

## **Summary**

### Java变量类型 ⭐⭐⭐⭐⭐
> 在Java语言中，所有的变量在使用前必须声明。type identifier = value
> Java语言支持的变量类型有:
> + 局部变量：类的方法中的变量。
> 声明位置：方法、构造方法或者语句块中。
> 存在周期：被执行的时候创建，当它们执行完成后，变量将会被销毁； 
> 访问修饰符：不能用于局部变量；  
> 分配位置：局部变量是在栈上分配的。  
> 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。
```
package com.runoob.test;
 
public class Test{ 
   public void pupAge(){
      int age = 0;
      age = age + 7;
      System.out.println("小狗的年龄是: " + age);
   }
   
   public static void main(String[] args){
      Test test = new Test();
      test.pupAge();
   }
}
```

> + 实例变量：独立于方法之外的变量，不过没有 static 修饰。
> 声明位置：声明在一个类中，但是在方法、构造方法和语句外。  
> 存在周期：在对象创建的时候创建，在对象被销毁的时候销毁； 
> 访问修饰符：可以修饰。  
> 实例变量可以声明在使用前或者使用后。  
> 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 
> 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定;  
> 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。
```
import java.io.*;
public class Employee{
   // 这个实例变量对子类可见
   public String name;
   // 私有变量，仅在该类可见
   private double salary;
   //在构造器中对name赋值
   public Employee (String empName){
      name = empName;
   }
   //设定salary的值
   public void setSalary(double empSal){
      salary = empSal;
   }  
   // 打印信息
   public void printEmp(){
      System.out.println("名字 : " + name );
      System.out.println("薪水 : " + salary);
   }
 
   public static void main(String[] args){
      Employee empOne = new Employee("RUNOOB");
      empOne.setSalary(1000);
      empOne.printEmp();
   }
}
```

> + 类变量：也称`静态变量`，独立于方法之外的变量，用 static 修饰。
> 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。  
> 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 
> 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。
```
import java.io.*;
 
public class Employee {
    //salary是静态的私有变量
    private static double salary;
    // DEPARTMENT是一个常量
    public static final String DEPARTMENT = "开发人员";
    public static void main(String[] args){
    salary = 10000;
        System.out.println(DEPARTMENT+"平均工资:"+salary);
    }
}
```


### Java修饰符 ⭐⭐⭐⭐⭐
> Java语言主要提供了两种修饰符：访问修饰符和非访问修饰符。  
> 修饰符用来定义`类`、`方法`或者`变量`。通常放在语句最前端。
> 访问控制修饰符：  
+ default（即默认，什么也不写）：在同一包内可见，不使用任何修饰符。使用对象：类、接口、对象、方法。
+ private：在同一类内可见，使用对象：变量、方法。注意不能修饰类。
+ public：对所有类可见。使用对象：类、方法、接口、变量。
+ protected：对同一包内的类和所有子类可见。使用对象：方法、变量，注意不能修饰类。
##### 默认访问修饰符--不使用任何关键字
> 使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。
```
String version = "1.5.1";
boolean processOrder() {
   return true;
}
```
##### 私有访问修饰符-private
> 私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。  
> 声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。  
> Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。
```
public class Logger {
    private String format;
    public String getFormat() {
        return this.format;
    }
    public String setFormat(String format) {
        this.format = format;
    }
}
```
##### 公有访问修饰符-public
> 被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。  
> 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包.
##### 受保护的控制修饰符-protected
> protected 需要从以下两个点来分析说明：
> + 子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；  
> + 子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。  

> protected 可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。
> 接口及接口的成员变量和成员方法不能声明为 protected。
</p>
</details>

---

# Oct-12,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*Java基础知识的学习--第三天*</u>

### 非访问修饰符 
##### static：用来修饰类方法和类变量
> + 静态变量： 
> static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。`局部变量不能被声明为 static 变量`。  
> + 静态方法：  
>  static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。

>  对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。
##### final：用来修饰类、方法和变量
> + final 变量：
>  final 表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。  
>  final 修饰符通常和 static 修饰符一起使用来创建类常量。  

> + final 方法
>  父类中的 final 方法可以被子类继承，但是不能被子类重写。  
>  声明 final 方法的主要目的是`防止该方法的内容被修改`。  
>  如下所示，使用 final 修饰符声明方法。

> + final 类
> final 类不能被继承，没有类能够继承 final 类的任何特性。 

#### abstract：用来创建抽象类和抽象方法
> + 抽象类：
> 抽象类`不能用来实例化对象`，声明抽象类的唯一目的是`为了将来对该类进行扩充`。  
> 一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。  
> `抽象类可以包含抽象方法和非抽象方法`。
实例
```
abstract class Caravan{
   private double price;
   private String model;
   private String year;
   public abstract void goFast(); //抽象方法
   public abstract void changeColor();
}
```
> + 抽象方法
> 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。  
> 抽象方法不能被声明成 final 和 static。  
> `任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。`  
> 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。   
> 抽象方法的声明以分号结尾，例如：public abstract sample();     
> 实例
```
public abstract class SuperClass{
    abstract void m(); //抽象方法
}
 
class SubClass extends SuperClass{
     //实现抽象方法
      void m(){
          .........
      }
}
```
#### synchronized 修饰符
> synchronized 关键字声明的方法同一时间只能被一个线程访问。
</p>
</details>


---

# Oct-14,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*Java基础知识的学习--第四天*</u>

##### 对所学Java不入门产生怀疑。对所写接口代码产生无所适从。

### Java String类
> 字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。 
> String类有11个构造方法，这些方法提供不同的参数来初始化字符串。  
> `注意`:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。  
> 如果需要对字符串做很多修改，那么应该选择使用 `StringBuffer` & `StringBuilder `类。

### Java方法
> 一般情况下，定义一个方法包含以下语法：

> 修饰符 返回值类型 方法名(参数类型 参数名){
>     ...
>    方法体
>    ...
>    return 返回值;
>}

### Java流(Stream)、文件(File)和IO
> 

### Java Scanner类
> 基本语法：Scanner s = new Scanner(System.in);

#### Java继承
>+ Java不支持多继承，但支持多重继承。
>+ 子类拥有父类非private的属性、方法。 
>+ 子类可以用自己的方式实现父类的方法。
>+ 继承关键字：extends和implements。  
>+ 所有的类都是继承自java.lang.Object。 
>+ final关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类充重写。  
>+ 子类是不继承父类的构造器的，它只是调用。

#### Java重写(Override)与重载(Overload)
> <b>重写(Override): </b>   
> 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
> <b>重载(Overload)：</b>   
>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

#### Java多态

#### Java抽象类
> 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类.  
> 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。

#### Java封装
> 在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。  
> 实现Java封装的步骤：  
> + 修改属性的可见性来限制对属性的访问（一般限制为private）.  
> + 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问.(getter,setter)

#### Java接口
> 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。  
>
> 类描述对象的属性和方法。接口则包含类要实现的方法。 
> 
> 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。
>
>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。
##### 接口特性
> 接口中的每一个方法都是隐私抽象的，接口中的方法会被隐士的指定为 `public abstract`(只能是 public abstract,其他修饰都会报错)。  
> 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 
> 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。

#### Java包
> 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。  
> package(包) 的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。
</p>
</details>

---

# Oct-15,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*Important principles may and must flexible.*</u>
> 重要的原则能够也必须是灵活的。

## **Plan**
> 这里记录我的一天，需要去留意的事。

> + 项目接口生成文档。  
> + 每日3+1问题回答。  
> + Java菜鸟的继续学习--完善文档至前两天。

## **Summary**
|        标签        |      记录      | 评价 |
|:------------------:|:--------------:|:----:|
|  项目接口生成文档  |      Done      |  ⭐⭐⭐  |
|  每日3+1问题回答   | 总结了一篇博文 |  ⭐⭐⭐  |
| Java菜鸟的继续学习 |      Done      |  ⭐⭐  |
| 晚上学习小程序云开发 |      Done      |  ⭐⭐  |


</p>
</details>

---

# Oct-16,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*That is the essence of sicenve: ask an  impertinent question,and you are on the way to the  pertinent answer.*</u>
> 科学的本质是：问一个不恰当的问题，于是走上了通往恰当答案的路。

## **Plan**
>这里记录我的一天，需要去留意的事。

> 每日3+1问题查看、思考、解答。
> 小程序云开发文档学习，结合【六个周】小程序。

## **Summary**
> 白日看3+1题感觉不怎么样，看不下去，这说明遇到了我不会的地方，且我懒得去研究，这是瓶颈，晚上回去继续攻破。

> 小程序云开发函数文档查看，且添加了一个小功能上传至小程序进行审核。
##### 小程序云开发需要提前深入理解的：
> 每条记录都有一个 _id 字段用以唯一标志一条记录、一个 _openid 字段用以标志记录的创建者，即小程序的用户。需要特别注意的是，在管理端（控制台和云函数）中创建的不会有 _openid 字段，因为这是属于管理员创建的记录。

| 标签  | 记录  | 评价  |
| :---: | :---: | :---: |
|  每日3+1问题     |       | ⭐  |
|  小程序云开发    |       | ⭐  |


</p>
</details>

---

# Oct-17,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*【主线程】*</u>
> 是杭州一对离职夫妻档自己创业而进行开发的一款小程序，此小程序开发功能比较完善，可当作，一款产品看待。 
> 此小程序注册记录为2019年6月21日，开发者为阜阳市读路网络科技有限公司，公司注册日期约为19年6月12日，可以关注一下这个16届毕业生的创业路。

## **Plan**
> 这里记录我的一天，需要去留意的事。

> 每日3+1问题查看、思考、解答.(Night Goal)  
> 小程序云开发文档再过一遍--比较深入的API并未继续研究。  
> 


## **Summary**
|       标签       |               记录                | 评价 |
|:----------------:|:---------------------------------:|:----:|
| 小程序云开发文档 |     比较深入的API并未继续研究     |  ⭐⭐  |
|   每日3+1问题    | optgroup/tranlate/面向对象/potman |  ⭐⭐  |

## Record
##### 聚合
> 云开发聚合文档看的有点不透彻。
##### 索引
> 根据官网描述：我们应为所有需要成为查询条件的字段建立索引。
##### 小程序端API 
| 语法                                    | 说明                                                       |
|:----------------------------------------|:-----------------------------------------------------------|
| wx.cloud.init({})                       | //初始化                                                   |
| wx.cloud.callFunction({})               | 调用云函数                                                 |
| wx.cloud.uploadFile({})                 | 本地资源上传至云存储空间                                   |
| wx.cloud.downloadFile({})               | 从云存储空间下载文件                                       |
| wx.cloud.deleteFile({})                 | 从云存储空间删除文件                                       |
| const db = wx.cloud.database({})        | 获取默认数据库的引用                                       |
| collection                              |                                                            |
| db.collection("test")                   | 获取集合的引用                                             |
| db.collection("test").doc("id")         | 获取记录的引用                                             |
| db.collection("test").get()             | 获取集合数据|获取根据查询条件筛选后的集合数据              |
| db.collection("test").add({data:{}})    | 在集合上新增记录                                           |
| db.collection("test").watch({})         | 监听集合中符合查询条件的数据更新事件 ，只要where语句会生效 |
| db.collection("test")...count()         | 统计集合记录数，一个用户仅能统计其有读权限的记录数         |
| db.collection("test").where({})         | 指定筛选条件                                               |
| db.collection("test").orderby('','')    | 指定查询排序条件                                           |
| db.collection("test").limit()           | 指定查询结果集数量上限                                     |
| db.collection("test").skip()            | 指定查询返回结果时从指定序列后的结果开始返回，常用于分页   |
| db.collection("test").filed({})         | 指定返回结果中记录需返回的字段                             |
| doc                                     |                                                            |
| db.collection("test").get()             | 获取记录数据，或获取根据查询条件筛选后的记录数据           |
| db.collection("test").update({data:{}}) | 更新一条记录                                               |
| db.collection("test").set({data:{}})    | 替换更新一条记录                                           |
| db.collection("test").remove()          | 删除一条记录                                               |
| db.command                              | 获取数据库查询及更新指令                                   |
| 后期略                                  |                                                            |
##### 服务端API
> 在 wx-server-sdk 中不再兼容 success、fail、complete 回调，总是只会返回 Promise。
```
const cloud = require('wx-server-sdk')
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})

exports.main = async (event) => {
  const { ENV, OPENID, APPID } = cloud.getWXContext()

  // 如果云函数所在环境为 abc，则下面的调用就会请求到 abc 环境的数据库
  const dbResult = await cloud.database().collection('test').get()

  return {
    dbResult,
    ENV,
    OPENID,
    APPID,
  }
}
```
| 语法         | 说明                                             |
|:-------------|:-------------------------------------------------|
| getWXContext | 在云函数中获取微信调用上下文，该方法无需传入参数 |

</p>
</details>

---

# Oct-18,2019

<details><summary><b>DETAILS</b></summary>
<p>


## **Daily Sentence**

## **Plan**
>这里记录我的一天，需要去留意的事。

## **Summary**
| 标签  | 记录  | 评价  |
| :---: | :---: | :---: |
|       |       | ⭐⭐  |
</p>
</details>

---

# Oct-19,2019

<details><summary><b>DETAILS</b></summary>
<p>

躺尸
</p>
</details>

---

# Oct-21,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*There are two sides to every story,at least.*</u>
> 每个故事都可以至少从两个方面看。

## **Plan**
>这里记录我的一天，需要去留意的事。

> + 小程序官方文档再深入、支付方面的流程梳理。
> + 极客时间课程--浏览器中的网络。

## **Summary**
> 早晨跑步第一天，跑了约2.17公里。  
> 学了两节极客时间浏览器渲染原理的课程，但是还不够深入。    
> 跟着aliya继续做JavaScript questions仓库题21-40.

</p>
</details>

---

# Oct-22,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*There's no place like home*</u>
> 没有一个地方可以和家相提并论。(《绿野仙踪》1939)

## **Plan**
> 这里记录我的一天，需要去留意的事。

> 小程序服务端接口调用流程梳理。

## **Summary**
|      标签       | 记录 | 评价 |
|:---------------:|:----:|:----:|
| running morning | 4km  | ⭐⭐⭐  |


## Record
#### 登录
> 登录凭证校验。通过 wx.login 接口获得临时登录凭证 code 后传到开发者服务器调用此接口完成登录流程。  
> `GET https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code`   
> 返回：openid、session_key、在满足 UnionID 下发条件的情况下会返回unionid。

#### access_token
> 获取小程序全局唯一后台接口调用凭据（access_token）。调调用绝大多数后台接口时都需使用 access_token，开发者需要进行妥善保存。   
> `GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET`.  
> 注意：
> + access_token 的存储至少要保留 512 个字符空间.   
> + access_token 的有效期目前为 2 个小时，需定时刷新，重复获取将导致上次获取的 access_token 失效；  
> + 这个字段值要手动保存、定时刷新、全局引用。  

#### templateMessage.send
> 组合模板并添加至帐号下的个人模板库（请注意，小程序模板消息接口将于2020年1月10日下线，开发者可使用订阅消息功能）.  
> so，这个不看了。

#### [订阅消息](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html)
> 流程一二三。  
> subscribeMessage.send:发送订阅消息。  
> `POST https://api.weixin.qq.com/cgi-bin/message/subscribe/send?access_token=ACCESS_TOKEN` 
> 所需参数：接收者（用户）的 openid、所需下发的订阅模板id。 

#### 微信支付
> + 微信支付要求商户订单号保持唯一性（建议根据当前系统时间加随机序列来生成订单号）. 
> + 重新发起一笔支付要使用原订单号，避免重复支付；已支付过或已调用关单、撤销（请见后文的API列表）的订单号不能重新发起支付。 
> + key为商户平台设置的密钥key:key设置路径：微信商户平台(pay.weixin.qq.com)-->账户设置-->API安全-->密钥设置.    

</p>
</details>

---

# Oct-23,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*Truth is a beautiful,Without doubt,and so lies.*</u>
> 真理是美的，毫无疑问，谎言也是。

## **Plan**
>这里记录我的一天，需要去留意的事。
> No plan.

## **Summary**
> 业余建了一个【技术开发吹水交流】群，两天时间到了100多人，真的是吹水群，一刻也不消停。

> 搞了一下统一下单，看了很多种类的代码，刚开始的时候我是抵触的，然后我告诫自己，写程序是一件酷酷的事，写自己不会的程序更是一件酷酷的事。    
> 生活如此美好，不多多去做酷酷的事情，真是浪费。


</p>
</details>

---

# Oct-24,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*Welcome new friends.This Group communicates in English.Thank for your cooperation.*</u>

## **Plan**
>这里记录我的一天，需要去留意的事。
> 写程序是一件酷酷的事，写自己不会的程序是一件更酷的事，今天重要写微信对接。

## **Summary**
|   标签   |     记录     | 评价 |
|:--------:|:------------:|:----:|
| 酷酷的事 | 没有酷酷的做 |  ⭐⭐  |

> 将微信登录获取openid、access_token、统一下单接口写了个差不多，万事虽不具备，但是可以进行测试了。

> 早晨跑了个5KM，不错不错。


</p>
</details>

---

# Oct-25,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*Growing old is not upsetting,being perceived as old is.   *</u>
> <cite> Oct 25,2019</cite>

## **Plan**
>这里记录我的一天，需要去留意的事。

> 今天要开始酷酷的写微信支付接口对接，代码已有、现在关键是跑通流程。    
> 遇到不懂的地方一定要停下来酷酷的解决。

## **Summary**
| 标签  | 记录  | 评价  |
| :---: | :---: | :---: |
|       |       | ⭐⭐  |

## Oct 26,2019
> 周五的晚上没回家，去了小盘子那里，今日一起吃了个饭，唱了个歌。

</p>
</details>

---

# Oct-28,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*Give a man a fish,and you feed him for a day.Teach a man to fish,and you get rid of him the weekends.*</u>
> 给他一条鱼，你可以喂他一天；教他钓鱼，周末就不会来烦你。

## **Plan**
>这里记录我的一天，需要去留意的事。

> Vue面试题。
> 统一下单。

## **Summary**
| 标签  | 记录  | 评价  |
| :---: | :---: | :---: |
|       |       | ⭐⭐  |

## **Record**
#### 从0到1自己构架一个vue项目，说说有哪些步骤、哪些重要插件、目录结构你会怎么组织
> 使用Vue-cli脚手架搭建、安装fastclick、better-scroll、1边框显示问题的border.css、引入reset样式文件，Vue-router、axios、根据开发业务挑选一个UI框架按需引入、目录结构的话，封装axios，统一调用风格和基本配置。

#### 你知道vue的模板语法用的是哪个web模板引擎的吗？说说你对这模板引擎的理解
> 模板引擎是以`业务逻辑层`和`表现层分离`为目的的，将规定格式的模板代码转换为业务数据的算法实现。    
> 它可以是一个过程代码、一个类，甚至是一个类库。不同的模板引擎其功用也不尽相同，但其基本原理都差不多。  
> 模板引擎的基本机理就是替换（转换）.

#### 你知道v-model的原理吗？
> v-model只是一个语法糖，真正实现靠的是 v-bind:绑定响应式数据，出发input事件并传递数据（核心和重点）。  
> `<input :value="msg" @input="msg =$event.target.value">`

#### 如何给vue定义全局方法
> 通过prototype、通过插件Vue.use(plugin)、通过mixin，Vue.mixin(minxins);

</p>
</details>

---

# Oct-29,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*To believe with certainly,we must begin with doubing*</u>

## **Plan**
> 这里记录我的一天，需要去留意的事。

> 空闲时间继续看Vue文档。

> 微信、小程序的登录，支付的统一下单

## **Summary**
|            标签            |   记录   | 评价 |
|:--------------------------:|:--------:|:----:|
|          Vue文档           |   还行   |  ⭐⭐  |
| 公众号登录、支付、查询订单 | 暂时顺利 |  ⭐⭐⭐  |

> 支付调试的还可以。    
> 统一下单正确、查询订单正确，还差具体参数的处理。

</p>
</details>

---

# Oct-30,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*We laughed and kept saying "see u soon",but inside we both knew we'd never see each other again. *</u>

## **Plan**
>这里记录我的一天，需要去留意的事。

> 今天把关于微信支付的内容处理完毕。    
> Vue.js官方文档，美滋滋的看着。    


## **Summary**
> 小程序与微信公众号的统一下单、查询订单、关闭订单接口流程是一样的。合并之。

> 其他的没有什么了，晚上回到我的小屋颓了一晚上。

</p>
</details>

---

# Oct-31,2019

<details><summary><b>DETAILS</b></summary>
<p>

## **Daily Sentence**
#### <u>*My mom always said life was like a box of chocolates. You never know what you're gonna get.*</u>

## **Plan**
>这里记录我的一天，需要去留意的事。

## **Summary**
> 微信支付相关接口差不多的写了一遍，但是漫漫测试路还有很长的路要走。    

> 今日是平凡、平淡没有收获的一个天。    
> 我一直想着自己每天沉浸来代码的世界里无法自拔. 
> 但其实所有的事情都为了有一个归宿，那么我沉浸来代码的世界里的归宿是什么？  
> 充实我的人生？丰满我的时间？升职加薪？寻找认同感？    
> 我早应该找到一件事去坚持他了。    

> 不管怎么样，我会成为一名优秀的程序员，只是如果时间来的太慢，不免让人急不可待。    
> Life was like a box of chocolates,We never know what we're gonna get.

</p>
</details>